diff --git a/cocoa/qcocoawindow.h b/cocoa/qcocoawindow.h
index 4e8649b..4089178 100644
--- a/cocoa/qcocoawindow.h
+++ b/cocoa/qcocoawindow.h
@@ -368,6 +368,10 @@ public: // for QNSView
     QHash<quintptr, bool> m_enabledContentBorderAreas; // identifer -> enabled state (true/false)
 
     bool m_hasWindowFilePath;
+    bool m_fullScreenActivated;
+    QRect m_normalGeo;
+    Qt::WindowFlags m_normalFlags;
+    NSApplicationPresentationOptions m_normalPresOpts;
 };
 
 QT_END_NAMESPACE
diff --git a/cocoa/qcocoawindow.mm b/cocoa/qcocoawindow.mm
index b0b5e59..20e6bcb 100644
--- a/cocoa/qcocoawindow.mm
+++ b/cocoa/qcocoawindow.mm
@@ -467,6 +467,7 @@ QCocoaWindow::QCocoaWindow(QWindow *tlw, WId nativeHandle)
     , m_topContentBorderThickness(0)
     , m_bottomContentBorderThickness(0)
     , m_hasWindowFilePath(false)
+    , m_fullScreenActivated(false)
 {
     qCDebug(lcQpaCocoaWindow) << "QCocoaWindow::QCocoaWindow" << window();
 
@@ -994,7 +995,8 @@ void QCocoaWindow::setWindowFlags(Qt::WindowFlags flags)
         Qt::WindowType type = window()->type();
         if ((type & Qt::Popup) != Qt::Popup && (type & Qt::Dialog) != Qt::Dialog) {
             NSWindowCollectionBehavior behavior = [m_nsWindow collectionBehavior];
-            if (flags & Qt::WindowFullscreenButtonHint) {
+            // Ignore Qt::WindowFullscreenButtonHint if a "simple" and consistent fullscreen mode is requested.
+            if ((flags & Qt::WindowFullscreenButtonHint) && !qEnvironmentVariableIsSet("QT_CONSISTENT_FULLSCREEN")) {
                 behavior |= NSWindowCollectionBehaviorFullScreenPrimary;
                 behavior &= ~NSWindowCollectionBehaviorFullScreenAuxiliary;
             } else {
@@ -1904,13 +1906,60 @@ void QCocoaWindow::toggleMaximized()
 
 void QCocoaWindow::toggleFullScreen()
 {
-    // The window needs to have the correct collection behavior for the
-    // toggleFullScreen call to have an effect. The collection behavior
-    // will be reset in windowDidEnterFullScreen/windowDidLeaveFullScreen.
-    m_nsWindow.collectionBehavior |= NSWindowCollectionBehaviorFullScreenPrimary;
+    // Use the "native" fullscreen mode if the window has the corresponding titlebar button
+    if (m_nsWindow.collectionBehavior & NSWindowCollectionBehaviorFullScreenPrimary) {
 
-    const id sender = m_nsWindow;
-    [m_nsWindow toggleFullScreen:sender];
+        const id sender = m_nsWindow;
+        [m_nsWindow toggleFullScreen:sender];
+    } else {
+        NSNotification *fullScreenNotification;
+        NSWindow *nsWin = m_view.window;
+        NSScreen *primaryScreen = [[NSScreen screens] firstObject];
+        NSApplication *nsApp = [NSApplication sharedApplication];
+        bool wasActive = ([NSApp keyWindow] == nsWin);
+#if QT_MACOS_PLATFORM_SDK_EQUAL_OR_ABOVE(__MAC_10_9)
+        bool menuBarsOnAllScreens = [NSScreen screensHaveSeparateSpaces];
+#else
+        // let's be exhaustive and assume we can be built on 10.8 or earlier
+        bool menuBarsOnAllScreens = false;
+#endif
+        if (m_fullScreenActivated) {
+            // exit from fullscreen mode
+            setWindowFlags(m_normalFlags);
+            setCocoaGeometry(m_normalGeo);
+            if (menuBarsOnAllScreens || [nsWin screen] == primaryScreen) {
+                // m_normalPresOpts is relevant only when the window was on the primary screen
+                // when made fullscreen but that should still be the case as fullscreen windows
+                // cannot be moved (easily).
+                [nsApp setPresentationOptions:m_normalPresOpts];
+            }
+            fullScreenNotification = [NSNotification notificationWithName:NSWindowDidExitFullScreenNotification
+                object:nsWin];
+            qCDebug(lcQpaCocoaWindow) << "Back from fullscreen ; geo=" << m_normalGeo;
+        } else {
+            m_normalGeo = windowGeometry();
+            if (menuBarsOnAllScreens || [nsWin screen] == primaryScreen) {
+                m_normalPresOpts = [nsApp presentationOptions];
+                [nsApp setPresentationOptions:m_normalPresOpts | NSApplicationPresentationAutoHideMenuBar | NSApplicationPresentationAutoHideDock];
+            }
+            m_normalFlags = m_windowFlags;
+            // unset WindowFullscreenButtonHint here because it can apparently interfere with the FramelessWindowHint,
+            // unsetting the latter and causing the window frame to be restored. Undesirable esp. since it
+            // will move the window downwards instead of resizing it.
+            setWindowFlags((m_windowFlags & ~Qt::WindowFullscreenButtonHint) | Qt::Window | Qt::FramelessWindowHint);
+            qCDebug(lcQpaCocoaWindow) << m_normalGeo << "to fullscreen" << QPlatformScreen::platformScreenForWindow(window())->geometry();
+            setCocoaGeometry(QPlatformScreen::platformScreenForWindow(window())->geometry());
+            fullScreenNotification = [NSNotification notificationWithName:NSWindowDidEnterFullScreenNotification
+                object:nsWin];
+        }
+        // send the notification used for setting m_view.window.qt_fullScreen
+        [[NSNotificationCenter defaultCenter] postNotification:fullScreenNotification];
+        if (wasActive) {
+            // make sure the operation doesn't cause a loss of focus
+            requestActivateWindow();
+        }
+    }
+    m_fullScreenActivated = !m_fullScreenActivated;
 }
 
 bool QCocoaWindow::isTransitioningToFullScreen() const
